#include <dt-bindings/gpio/gpio.h>

#include "../rtl8730e.dtsi"
#include "stream210-nand-256m.dtsi"

/ {
	model = "StreamUnlimited Stream210 module (Realtek Ameba)";
	compatible = "sue,stream210", "realtek,ameba";

	chosen {
		stdout-path = &loguart;
	};

	cpus {
		cpu@0 {
			clock-frequency = <1280000000>;
			freq_tab = <640000 1280000>;

		};

		cpu@1 {
			clock-frequency = <1280000000>;
			freq_tab = <640000 1280000>;
		};
	};

	memory {
		device_type = "memory";
		reg = <0x60800000 0xF800000>;  // 256MB -- exclude 8 MiB secure memory
	};

	reserved-memory {
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		ramoops@64600000 {
			compatible = "ramoops";

			// 128 KiB buffer
			reg = <0x64600000 0x20000>;

			// We only care about a single crash/entry from the last boot,
			// so make `record-size` equal to the total size
			record-size = <0x20000>;

			// Only dump panics, in our configuration we are setting
			// `panic_on_oops=1` anyway which will log it.
			no-dump-oops;
		};
	};

	reg_usb_drvvbus: reg-usb-drvvbus {
		pinctrl-names = "default";
		pinctrl-0 = <&usb_drvvbus_pin>;
		compatible = "regulator-fixed";
		regulator-name = "usb_drvvbus";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		gpio = <&gpiob 28 0>;
		enable-active-high;
	};
};

&aes {
	status = "okay";
};

&axi_wlan {
	// According to Realtek these pins are supposedly to be used for antenna
	// switching, etc. However they are currently not handeled by the driver
	// and create a conflict on our module, so let's remove them.
	/delete-property/pinctrl-names;
	/delete-property/pinctrl-0;
};

&hash {
	status = "okay";
};

&loguart {
	wakeup-source;
};

&pinctrl {
	usb_drvvbus_pin: usb_drvvbus_pin@0 {
		pins {
			pinmux = <REALTEK_PINMUX('B', 28, GPIO)>;
			bias-pull-down;
		};
	};

	dmic_pins_stream210: dmic_pins_stream210@0 {
		pins {
			pinmux = <REALTEK_PINMUX('B', 7, DMIC)>,		// DMIC0_CLK
					<REALTEK_PINMUX('B', 9, DMIC)>,		// DMIC0_DATA0
					<REALTEK_PINMUX('B', 10, DMIC)>;	// DMIC0_DATA1
			bias-disable;
		};
	};
};

&i2c0 {
	// The default is something like 2 seconds which is way too
	// long as it seem to stop the kernel for that amount of time.
	rtk,wait-timeout = <100>;
};

&i2c1 {
	// The default is something like 2 seconds which is way too
	// long as it seem to stop the kernel for that amount of time.
	rtk,wait-timeout = <100>;
};

&i2c2 {
	// The default is something like 2 seconds which is way too
	// long as it seem to stop the kernel for that amount of time.
	rtk,wait-timeout = <100>;
};

&misc{
	rtk,ddr-auto-gating-ctrl = <1>;
};

&sport {
	// Setting this parameter will force the SPORT0 interface to use
	// the audio PLLs as the clock sources. The SPORT0 is internally
	// connected to the internal DAC and does not need any MCLK actually.
	rtk,sport-mclk-multiplier = <256>;
};

&usb {
	vbus-supply = <&reg_usb_drvvbus>;
	status = "okay";
};

&watchdog {
	status = "okay";

	// Disable interrupt mode which would generate an interrupt before the
	// watchdog timer fires. In the current implementation the kernel will
	// actually pet the watchdig in this interrupt which does not make
	// sense for our use-case.
	rtk,wdg-interrupt-mode = <0>;

	// It is not possible to reconfigure the watchdog timeout and we
	// are already configuring the watchdog to 30 seconds in u-boot
	// so set it here to the same value to be consistent.
	rtk,wdg-timeout = <30>;
};
