
#include "imx8mm-pad.h"
#include "../freescale/imx8mm.dtsi"

/ {
	model = "StreamUnlimited Stream195x module (i.MX8MM)";
	compatible = "sue,stream195x", "fsl,imx8mm";

	bt_reset: modem-reset {
		compatible = "gpio-reset";
		reset-gpios = <&gpio2 10 GPIO_ACTIVE_LOW>;
		reset-delay-us = <2000>;
		reset-post-delay-ms = <40>;
		#reset-cells = <0>;
	};

	reserved-memory {
		/*
		 * The allocator settings inside fsl-imx8mm.dtsi are
		 * for the NXP reference design which has 2 GiB of RAM.
		 * And this reservation was failing for us, so remove
		 * it to get rid of an error message on boot.
		 */
		/delete-node/linux,cma;
	};

	simple-busfreq {
		compatible = "sue,simple-busfreq-imx8mm";
		clocks = <&clk IMX8MM_CLK_NOC>,
			 <&clk IMX8MM_CLK_AHB>,
			 <&clk IMX8MM_CLK_MAIN_AXI>,
			 <&clk IMX8MM_CLK_24M>,
			 <&clk IMX8MM_SYS_PLL2_333M>;
		clock-names = "noc_div",
			      "ahb_div",
			      "main_axi_src",
			      "osc_24m",
			      "sys_pll2_333m";
	};

	gpio-keys {
		compatible = "gpio-keys";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_onoff>;

		button_sense {
			label = "button_sense";
			/* The BUTTON_SENSE is the inverted NPB_IN_N so it becomes active high. */
			gpios = <&gpio5 27 GPIO_ACTIVE_HIGH>;
			linux,code = <KEY_POWER>;
			wakeup-source;
		};
	};

	/*
	 * This is used by the new Ampak/Broadcom out-of-tree driver.
	 * Older driver versions will just ignore this node and have
	 * the GPIOs hardcoded.
	 */
	bcmdhd {
		compatible = "android,bcmdhd_wlan";
		gpio_wl_reg_on = <&gpio2 8 GPIO_ACTIVE_HIGH>;
		gpio_wl_host_wake = <&gpio2 9 GPIO_ACTIVE_HIGH>;
	};
};

&A53_0 {
	cpu-supply = <&vdd_arm>;
};

&busfreq {
	/*
	 * Disable the NXP busfreq driver because it is way too overcomplicated for
	 * our needs, instead we will use our own, simple driver.
	 */
	status = "disabled";
};

&crypto {
	status = "disabled";
};

&caam_sm {
	status = "disabled";
};

&i2c1 {
	/*
	 * Workaround for:
	 *   e7805: I2C: When the I2C clock speed is configured for 400 kHz, the SCL low period
	 *   violates the I2C spec of 1.3 uS min
	 */
	clock-frequency = <384000>;

	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c1>;
	status = "okay";

	pmic: axp15060@36 {
		compatible = "x-powers,axp15060";
		reg = <0x36>;

		regulators {
			vdd_arm: dcdc2 {
				regulator-name = "vdd_arm";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <1000000>;
				regulator-boot-on;
				regulator-always-on;
			};

			wifi_conv_3v3: aldo4 {
				regulator-name = "wifi_conv_3v3";
				regulator-min-microvolt = <3300000>;
				regulator-max-microvolt = <3300000>;
				regulator-always-on;
			};
		};
	};
};

&iomuxc {
	imx8mm-s195x-internal {
		pinctrl_i2c1: i2c1grp {
			fsl,pins = <
				MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			(IOMUX_CONFIG_SION | PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			(IOMUX_CONFIG_SION | PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
			>;
		};

		pinctrl_uart2: uart2grp {
			fsl,pins = <
				MX8MM_IOMUXC_UART2_RXD_UART2_DCE_RX	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_UART2_TXD_UART2_DCE_TX	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_UART4_RXD_UART2_DCE_CTS_B	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_UART4_TXD_UART2_DCE_RTS_B	(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_SD1_RESET_B_GPIO2_IO10	(PAD_CTL_PE_UP | PAD_CTL_HYS)	/* WLAN_BT_REG_ON */
				MX8MM_IOMUXC_SD1_STROBE_GPIO2_IO11	(PAD_CTL_PE_UP | PAD_CTL_HYS)	/* BT_HOST_WAKE */
			>;
		};

		pinctrl_usdhc1: usdhc1grp {
			fsl,pins = <
				MX8MM_IOMUXC_SD1_CLK_USDHC1_CLK		(PAD_CTL_PE_DOWN | PAD_CTL_SLOW | PAD_CTL_DSE1x)
				MX8MM_IOMUXC_SD1_CMD_USDHC1_CMD		(PAD_CTL_PE_UP | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_SD1_DATA0_USDHC1_DATA0	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_SD1_DATA1_USDHC1_DATA1	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_SD1_DATA2_USDHC1_DATA2	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_SD1_DATA3_USDHC1_DATA3	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
			>;
		};

		pinctrl_usdhc3: usdhc3grp {
			fsl,pins = <
				MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x190
				MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d0
				MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d0
				MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d0
				MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d0
				MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d0
				MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d0
				MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d0
				MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d0
				MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d0
				MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE 		0x190
			>;
		};

		pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
			fsl,pins = <
				MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x194
				MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d4
				MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d4
				MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d4
				MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d4
				MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d4
				MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d4
				MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d4
				MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d4
				MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d4
				MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE 		0x194
			>;
		};

		pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
			fsl,pins = <
				MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x196
				MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d6
				MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d6
				MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d6
				MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d6
				MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d6
				MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d6
				MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d6
				MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d6
				MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d6
				MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE 		0x196
			>;
		};

		pinctrl_wdog: wdoggrp {
			fsl,pins = <
				MX8MM_IOMUXC_GPIO1_IO02_WDOG1_WDOG_B	(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_DSE6x)
			>;
		};

		pinctrl_wifi: wifigrp {
			fsl,pins = <
				MX8MM_IOMUXC_SD1_DATA5_GPIO2_IO7	(PAD_CTL_PE_UP | PAD_CTL_HYS)	/* WIFI_IRQ (OOB) */
				MX8MM_IOMUXC_SD1_DATA6_GPIO2_IO8	(PAD_CTL_PE_UP | PAD_CTL_HYS)	/* WLAN_WL_REG_ON */
				MX8MM_IOMUXC_SD1_DATA7_GPIO2_IO9	(PAD_CTL_PE_UP | PAD_CTL_HYS)	/* WLAN_HOST_WAKE */
			>;
		};

		pinctrl_onoff: gpiogrp {
			fsl,pins = <
				MX8MM_IOMUXC_UART3_TXD_GPIO5_IO27	(PAD_CTL_PE_UP | PAD_CTL_HYS)
			>;
		};
	};
};

&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart2>;
	uart-has-rtscts;
	assigned-clocks = <&clk IMX8MM_CLK_UART2>;
	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_80M>;
	/* TODO: Make sure the reset gets toggled on boot */
	resets= <&bt_reset>;
	status = "okay";
};

&uart4 {
	/*
	 * To enable UART4 in Linux, you need to comment out
	 * RDC_PDAPn(RDC_PDAP_UART4, D1R | D1W),
	 * in plat/imx/imx8m/imx8mm/imx8mm_bl31_setup.c in imx-atf
	 */
};

&usdhc1 {
	/* TODO: check if we maybe need different pinctrl settings for the different speeds */
	pinctrl-names = "default", "state_100mhz", "state_200mhz";
	pinctrl-0 = <&pinctrl_usdhc1>, <&pinctrl_wifi>;
	pinctrl-1 = <&pinctrl_usdhc1>, <&pinctrl_wifi>;
	pinctrl-2 = <&pinctrl_usdhc1>, <&pinctrl_wifi>;
	bus-width = <4>;
	pm-ignore-notify;
	keep-power-in-suspend;
	non-removable;

	/*
	 * This configures the SDIO clocks to run at 187.5 MHz instead of the
	 * default 200 MHz. Main reason is the reduction of EMI by the SDIO
	 * clock.
	 */
	assigned-clocks = <&clk IMX8MM_CLK_USDHC1>;
	assigned-clock-parents = <&clk IMX8MM_SYS_PLL3_OUT>;
	assigned-clock-rates = <375000000>;

	status = "okay";
};

&usdhc3 {
	pinctrl-names = "default", "state_100mhz", "state_200mhz";
	pinctrl-0 = <&pinctrl_usdhc3>;
	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
	bus-width = <8>;
	non-removable;
	status = "okay";
};

&wdog1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_wdog>;
	fsl,ext-reset-output;
	status = "okay";
};
