
/ {
	reg_usb1_drvvbus: regulator@0 {
		compatible = "regulator-fixed";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_usb1_drvvbus>;

		regulator-name = "usb1_drvvbus";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio1 10 GPIO_ACTIVE_HIGH>;
	};

	reg_usb2_drvvbus: regulator@1 {
		compatible = "regulator-fixed";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_usb2_drvvbus>;

		regulator-name = "usb2_drvvbus";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio1 11 GPIO_ACTIVE_HIGH>;
	};

	sound-pcm {
		compatible = "sue,stream195x-audio";
		sue-card,name = "Stream Audio on i.MX8MM";

		clocks = <&clk IMX8MM_AUDIO_PLL1_OUT>, <&clk IMX8MM_AUDIO_PLL2_OUT>;
		clock-names = "pll8k", "pll11k";

		powerdown-gpios = <&gpio1 6 GPIO_ACTIVE_LOW>;

		sue-card,dai-link@0 {
			format = "i2s";

			/*
			 * Do not disable the BCLK and WCLK after playback has stopped
			 * This only really makes sense if the cpu is the clock master
			 */
			continuous-clock;

			frame-master = <&dailink0_cpu>;
			bitclock-master = <&dailink0_cpu>;

			mute-gpios = <&gpio1 4 GPIO_ACTIVE_LOW>;

			/*
			 * This makes sure we always output 2 channels @ 32 bit I2S data, even
			 * on lower bit depths.
			 */
			dai-tdm-slot-num = <2>;
			dai-tdm-slot-width = <32>;

			dailink0_cpu: cpu {
				sound-dai = <&sai5>;
			};

			codec {
				use-dummy-codec;
			};
		};
	};

	sound-pdm {
		compatible = "fsl,imx-audio-micfil";
		model = "imx-audio-micfil";
		cpu-dai = <&micfil>;
	};
};

&clk {
	assigned-clocks = <&clk IMX8MM_AUDIO_PLL1>, <&clk IMX8MM_AUDIO_PLL2>;
	assigned-clock-rates = <786432000>, <722534400>;
};

&fec1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_fec1>;
	phy-mode = "rmii";
	phy-handle = <&ethphy0>;
	status = "okay";

	phy-reset-gpios = <&gpio1 29 GPIO_ACTIVE_LOW>;
	phy-reset-duration = <5>;
	phy-reset-post-delay = <5>;


	/*
	 * Override assigned-clocks and assigned-clock-rates from
	 * fsl-imx8mm.dtsi by adding IMX8MM_CLK_ENET_REF_DIV with
	 * 50 MHz to the list and setting rate of IMX8MM_CLK_ENET_REF_SRC
	 * to 100 MHz.
	 */
	assigned-clocks = <&clk IMX8MM_CLK_ENET_AXI_SRC>,
			  <&clk IMX8MM_CLK_ENET_TIMER_SRC>,
			  <&clk IMX8MM_CLK_ENET_REF_SRC>,
			  <&clk IMX8MM_CLK_ENET_TIMER_DIV>,
			  <&clk IMX8MM_CLK_ENET_REF_DIV>;
	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_266M>,
				 <&clk IMX8MM_SYS_PLL2_100M>,
				 <&clk IMX8MM_SYS_PLL2_100M>;
	assigned-clock-rates = <0>, <0>, <100000000>, <100000000>, <50000000>;

	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@0 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <0>;
		};
	};
};

&i2c4 {
	/*
	 * Workaround for:
	 *   e7805: I2C: When the I2C clock speed is configured for 400 kHz, the SCL low period
	 *   violates the I2C spec of 1.3 uS min
	 */
	clock-frequency = <384000>;

	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_i2c4>;
	status = "okay";
};

&iomuxc {
	imx8mm-s195x-external {
		pinctrl_fec1: fec1grp {
			fsl,pins = <
				MX8MM_IOMUXC_ENET_MDC_ENET1_MDC			(IOMUX_CONFIG_SION | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_ENET_MDIO_ENET1_MDIO		(PAD_CTL_DSE6x)
				MX8MM_IOMUXC_ENET_TD2_ENET1_TX_CLK		(IOMUX_CONFIG_SION | PAD_CTL_SLOW | PAD_CTL_DSE1x)
				MX8MM_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		(PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		(PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	(PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	(PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_ENET_RXC_ENET1_RX_ER		(PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		(PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		(PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_ENET_RD2_GPIO1_IO28		(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST)	/* PHY_INT_N */
				MX8MM_IOMUXC_ENET_RD3_GPIO1_IO29		(PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST)	/* PHY_RST_N */

			>;
		};

		pinctrl_i2c4: i2c4grp {
			fsl,pins = <
				MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			(IOMUX_CONFIG_SION | PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
				MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			(IOMUX_CONFIG_SION | PAD_CTL_PE_UP | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE6x)
			>;
		};

		pinctrl_pdm: pdmgrp {
			fsl,pins = <
				MX8MM_IOMUXC_SAI1_RXD0_PDM_DATA0		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_SAI1_RXD1_PDM_DATA1		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_SAI1_RXD2_PDM_DATA2		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_SAI1_RXD3_PDM_DATA3		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_SAI1_TXD7_PDM_CLK			(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE4x)
			>;
		};

		pinctrl_sai5: sai5grp {
			fsl,pins = <
				MX8MM_IOMUXC_SAI5_RXD0_SAI5_RX_DATA0		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST)
				MX8MM_IOMUXC_SAI5_MCLK_SAI5_MCLK		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE4x)
				MX8MM_IOMUXC_SAI2_RXFS_SAI5_TX_SYNC		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE4x)
				MX8MM_IOMUXC_SAI2_RXC_SAI5_TX_BCLK		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE4x)
				MX8MM_IOMUXC_SAI2_RXD0_SAI5_TX_DATA0		(PAD_CTL_PE_DOWN | PAD_CTL_HYS | PAD_CTL_FAST | PAD_CTL_DSE4x)
			>;
		};

		pinctrl_uart1: uart1grp {
			fsl,pins = <
				MX8MM_IOMUXC_UART1_RXD_UART1_DCE_RX	(PAD_CTL_PE_DOWN | PAD_CTL_HYS)
				MX8MM_IOMUXC_UART1_TXD_UART1_DCE_TX	(PAD_CTL_PE_DOWN | PAD_CTL_HYS)
			>;
		};

		pinctrl_usb1_drvvbus: usb1drvvbusgrp {
			fsl,pins = <
				MX8MM_IOMUXC_GPIO1_IO10_GPIO1_IO10	(PAD_CTL_PE_DOWN | PAD_CTL_HYS)
			>;
		};

		pinctrl_usb2_drvvbus: usb2drvvbusgrp {
			fsl,pins = <
				MX8MM_IOMUXC_GPIO1_IO11_GPIO1_IO11	(PAD_CTL_PE_DOWN | PAD_CTL_HYS)
			>;
		};
	};
};

&micfil {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_pdm>;
	assigned-clocks = <&clk IMX8MM_CLK_PDM_SRC>, <&clk IMX8MM_CLK_PDM_DIV>;
	assigned-clock-parents = <&clk IMX8MM_AUDIO_PLL1_OUT>;
	assigned-clock-rates = <0>, <196608000>;
	status = "okay";
};

&sai5 {
	#sound-dai-cells = <0>;	/* This is required for the simple-audio-card to work */
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_sai5>;
	assigned-clocks = <&clk IMX8MM_CLK_SAI5_SRC>,
			<&clk IMX8MM_CLK_SAI5_DIV>;
	assigned-clock-parents = <&clk IMX8MM_AUDIO_PLL1_OUT>;
	assigned-clock-rates = <0>, <24576000>;

	/* This only adds the pll8k and the pll11k clock to the list */
	clocks = <&clk IMX8MM_CLK_SAI5_IPG>, <&clk IMX8MM_CLK_DUMMY>,
		 <&clk IMX8MM_CLK_SAI5_ROOT>, <&clk IMX8MM_CLK_DUMMY>,
		 <&clk IMX8MM_CLK_DUMMY>,
		 <&clk IMX8MM_AUDIO_PLL1_OUT>, <&clk IMX8MM_AUDIO_PLL2_OUT>;
	clock-names = "bus", "mclk0",
		      "mclk1", "mclk2",
		      "mclk3",
		      "pll8k", "pll11k";

	status = "okay";
};

&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart1>;
	status = "okay";
};

&usbotg1 {
	dr_mode = "host";
	status = "okay";
	vbus-supply = <&reg_usb1_drvvbus>;
};

&usbotg2 {
	dr_mode = "host";
	status = "okay";
	vbus-supply = <&reg_usb2_drvvbus>;
};

